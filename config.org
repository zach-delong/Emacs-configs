#+TITLE: Emacs Configuration
* What is this?

  This literate file rep literate programming to make it easier to document the strange and arcane things that I sometimes have to do while learning more about Emacs. Hopefully this makes it easier to maintain and change in the future.

  It is worth noting that the vast majority of this config is intended to be used with Evil Mode. I am starting to move back into vanilla Emacs style keybindings, though. I try to explain what is what as I go.
  
* Pre-configuration

  Before I actually configure anything interesting, I need to do  certain things (like install use-package). In this section, do not  assume that anything has been installed, but configure things that  are generic (at least in theory) to any configuration of Emacs.

** package.el

First up, I have to make sure that [[https://repo.or.cz/w/emacs.git/blob_plain/HEAD:/lisp/emacs-lisp/package.el][package.el]] is configured. Package.el is a package manager that's built into GNU Emacs (apparently since Emacs24). I will be using ~use-package~ for the most part, but I will have to bootstrap that somehow and for now package.el (which is built in anywhere I have needed it) fits fine.

   #+BEGIN_SRC emacs-lisp :tangle config.el
     (require 'package)
   #+END_SRC 

*** Package repositories

    By default my config uses [[https://melpa.org/][MELPA]]. I would love to rely on [[http://elpa.gnu.org/][ELPA]] more, but I have had issues with timely resolution of issues, so for now I am primarily using MELPA.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (add-to-list 'package-archives
		   '("melpa" . "https://melpa.org/packages/") t)
    #+END_SRC

    We also want to make sure we are pulling from sources in a way that keeps with our priorities. Since I have had issues with ELPA having up to date packages, I am giving MELPA highest priority, then nongnu ELPA, followed by ELPA. I would love to flip this around eventually, but right now this is working well.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (setq package-archive-priorities
	    '(("gnu"    . 1)
	      ("nongnu" . 2)
	      ("melpa" . 3)))
    #+END_SRC

*** Initialization

    To set up ~package.el~ I need to call ~package-initialize~.
    
    #+BEGIN_SRC emacs-lisp :tangle config.el
      (package-initialize t)
    #+END_SRC

** Use-package

   Now that package.el is set up, I can finally install and use ~use-package~! [[https://github.com/jwiegley/use-package/tree/a7422fb8ab1baee19adb2717b5b47b9c3812a84c#use-package][Use-package]] is a crazy macro that does a lot of things but I am primarily using it to lazy-load things (using ~package.el~) and to consolidate the list of plugins I am using with their configuration. I am also using the installation of ~use-package~ as an indicator that this is the first run. I don't want to refresh packages every time I start up Emacs, that would take forever, so I am refreshing them if use-package is not already installed. If it isn't, then clearly my config hasn't been run before, so we should refresh package contents before doing the initial setup.

   #+BEGIN_SRC emacs-lisp :tangle config.el
     (unless (package-installed-p 'evil)
       (package-refresh-contents))
   #+END_SRC

*** A brief introduction to use-package

    Use package has a ton of options that I frequently forget how to use, so I want to explain a few of them here for future reference. One of the big benefits is that nothing is loaded by `use-package` until a provided feature is actually requested. This means that you can defer configuration easily!

**** Basic use-package and ensure

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package evil
	 :ensure t)
     #+END_SRC
     When you include a package via ~use-package~ you simply specify the name of the package. That will look at your load-path and try to find a package that matches the name you've listed. This doesn't actually install anything! It just looks at what is already installed and set up on your load path. If you would like ~use-package~ to actually load packages from your package archive(s) for you, you can provide the ~:ensure~ option. By default this will cause it to load using ~package.el~, but I have heard that you can also use straight.el as well.

**** Configuring things

     In general, it's not a good idea to assume that a package is always loaded. If you want to set things up only when a given package is actually loaded, do your configuration in the `:config` section of the use-package instance

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package evil
	 :ensure t
	 :config
	 (format "Hello, world this should only show up when evil is actually loaded"))
     #+END_SRC

     You can also use the `:init` block if you want it to happen before the package is loaded.

** Customization file

   Emacs allows you to set certain customizations via its own UI. When you do that, it has to save it somewhere and by default it saves in the ~init.el~ file. I would like to keep that file as simple as possible, so I am going to put those customizations in a separate file.

   #+BEGIN_SRC emacs-lisp :tangle config.el
     (setq custom-file "~/.emacs.d/custom.el")
     (load custom-file)
   #+END_SRC

* Configuration

  This is where the meat-and-potatoes of my configuratoin will live.

** Utilities

*** Insert file name

    Inserts the current file name.
    #+BEGIN_SRC emacs-lisp :tangle config.el
      (defun insert-file-name ()
	"Insert the file name into the current buffer (at point)."
	(interactive)
	(insert (file-name-nondirectory
		 (buffer-file-name
		  (window-buffer
		   (minibuffer-selected-window))))))
    #+END_SRC

*** Yank current file name

    Pulls out the current file name

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (defun evil-yank-file-name ()
	"yank the file name associated with the current buffer."
	(interactive)
	(kill-new
	 (file-name-nondirectory
	  (buffer-file-name
	   (window-buffer
	    (minibuffer-selected-window))))))
    #+END_SRC

*** Switch to the scratch buffer

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (defun switch-to-scratch ()
	"Switches to the scratch buffer"
	(interactive)
	(switch-to-buffer "*scratch*"))
    #+END_SRC

*** Global auto revert

    In most modern editors, when a file changes on disk, the editor warns you or even automatically reads the file on disk! This is really useful if you, for example, run a git pull, or have a file system sync tool like Dropbox. This should enable just such a feature that is built into most modern Emacs.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (setq auto-revert-check-vc-info t)
      (global-auto-revert-mode)
    #+END_SRC 
** Local configuration

   This file is set up only so that you can set any local variables you might need.  For example, if you are loading on Windows you might need to set some file paths to your org files that are different from the defaults I have checked in. If this file exists (and it should be ignored in the Git repo) then Emacs will tangle and execute it just like this file. If not, it will ignore and continue. 

   #+BEGIN_SRC emacs-lisp :tangle config.el
     (setq local-file-path "~/.emacs.d/local.org")
     (if (file-exists-p local-file-path)
	 (org-babel-load-file local-file-path))
   #+END_SRC

** Packages
*** Evil-mode

    [[https://github.com/emacs-evil/evil][Evil mode]] is the vim emulation layer.  I am using use-package to install and enable it. 

    #+BEGIN_SRC emacs-lisp :noweb yes :tangle config.el
      (use-package evil
	:ensure t
	:init
	<<evil-init-config>>
	:config
	(evil-mode 1)
	<<evil-keybindings>>)
    #+END_SRC

**** Evil init
     :PROPERTIES:
     :header-args: :noweb-ref evil-init-config
     :END:

     This section will be inserted into my use-package definition in the ~:init~ block, so it's executed before evil mode is loaded.

***** TODO keybindings?

      I am really not sure why this is here. It appears to have to do with [[*Evil-collection][evil-collection]]. I should come back to this and figure out what it is doing.

      #+BEGIN_SRC emacs-lisp :tangle no
	(setq evil-want-keybinding nil)
      #+END_SRC

***** Scrolling keybindings

      There are some keybindings where Emacs native and Evil-mode keybindings clash. Control + U is one of them. In Emacs, C-u is a prefix binding that lets you provide parameters to other commands, but in normal mode in Vim, C-u is page up. I prefer that it behave like Vim, which this should do

      #+BEGIN_SRC emacs-lisp :tangle no
	(setq evil-want-C-u-scroll t)
      #+END_SRC

***** Visual line mode

      #+BEGIN_SRC emacs-lisp :tangle no
	(setq evil-respect-visual-line-mode 1)
      #+END_SRC
**** Evil keybindings
     :PROPERTIES:
     :header-args: :noweb-ref evil-keybindings
     :END:

     I have a ton of various keybindings that all don't really relate to a particular plugin, and those keybindings are all set up here and explained as much as I could provide

     While I am generally familiar with [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Keymaps.html][keymaps]] in Emacs, I am not yet so comfortable with them that I am building and manipulating them directly. [[https://evil.readthedocs.io/en/latest/keymaps.html][Instead, I have most of my keybindings set using normal]] ~evil-define-key~ to add things to the appropriate map for the mode/whatever combination.

***** Leader

      On top of using the evil methods for defining keymaps, I am also using Evil mode's built [[https://evil.readthedocs.io/en/latest/keymaps.html#leader-keys][support for leader and local leader keys]]. I am using this basically to support Spacemacs style leader keybindings where all my keybindings are "hidden" behind the space key in normal and other similar modes (visual, motion, etc). I am also using local leader to hide "major mode specific bindings." So ~SPC M~ should always trigger hotkeys for the current major mode.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-set-leader '(normal motion visual emacs) (kbd "SPC"))
	(evil-set-leader '(motion) (kbd "M-SPC"))
	;; In progress, this doesn't seem to be doing anything
	(evil-set-leader '(normal motion visual emacs) (kbd "<leader> m") t)
      #+END_SRC

***** Misc unsorted hotkeys

      This section is just some meta keybindings that don't relate nicely to one topic area.

      First up, I like to run arbitrary Elisp functions constantly, and the default ~M-x~ isn't terribly ergonomic to me. what I do find ergonomic is ~leader SPC~ which currently evaluates to just being ~SPC SPC~. This does also leave the default ~M-x~ in place for use when in edit mode.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> SPC") 'execute-extended-command)
      #+END_SRC

      I also tend to go back and forth between buffers a lot, so I have ~leader tab~ and ~leader shift+tab~ bound to work sort of like control + tab and control + shift + tab on a normal modern web browser.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> <tab>") 'previous-buffer)
      #+END_SRC

      This binding makes the shift+tab work in Windows specifically.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> <S-tab>") 'next-buffer)
      #+END_SRC

      Unfortunately, that doesn't work on Linux, which seems to use <backtab> as a separate key.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> <backtab>") 'next-buffer)
      #+END_SRC

      Do you like quitting Emacs?  Me neither, but occasionally I need to do it. Often I do that with ~ZZ~ in normal mode, but until I discovered that, I often used this.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> q f") 'save-buffers-kill-terminal)
      #+END_SRC


***** File manipulation hotkeys

      All of these are prefixed with ~<leader> f~ to denote that they have to do with file manipulation.

      First up, a hotkey for writing whatever the current file is. This is equivalent to ~:w~ in Vim, or ~C-x C-s~ in Emacs.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> f s") 'save-buffer)
      #+END_SRC

      I also frequently edit many files at once and want to write them all at once. This should allow that.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> f S") 'evil-write-all)
      #+END_SRC

      Another frequent need of mine is to copy the name of the file that the current buffer is visiting.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> f y") 'evil-yank-file-name)
      #+END_SRC


      I also don't like the default emacs ~C-x C-f~ for finding files, so I have swapped it under my file manipulation keybindings.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> f f") 'find-file)
      #+END_SRC


****** Dired

       Dired is a pretty incredible little program that you can use to navigate around your file system. It has really interesting integration with find as well.

       The basic dired command is simple enough. This should make it possible to open a file system buffer wherever your current buffer happens to be pointing.

       #+BEGIN_SRC emacs-lisp :tangle no
	 (evil-global-set-key 'normal (kbd "<leader> f d d") 'dired)
       #+END_SRC

       There are also commands that can pipe the output of find to a buffer, for you to perform bulk operations on. [[https://www.masteringemacs.org/article/working-multiple-files-dired][See here for more info]]. The only real difference is that the ~lisp~ variant is written in emacs lisp and works in environments that might not have GNU Find installed. Below I've written a program that checks to see if you have ~find~ installed. If you do, it calls out to it interactively (so as though you had executed it interactively yourself via a keybinding or via calling ~execute-extended-comand~. If you don't, it falls back to the ~lisp~ implementation of ~find~, which might be significantly slower, but should work in any environment.

       #+BEGIN_SRC emacs-lisp :tangle no
	 (defun find-name-dired-fallback ()
	     "Runs the local executable 'find' CLI program (if it exists) and
	 pipes the output to dired. If it does not exist, it will fallback
	 to using the elisp implementation which may be slower."
	   (interactive)
	   (if (not (eq (executable-find "find") nil))
	       (call-interactively 'find-name-dired) 
	     (call-interactively 'find-lisp-find-dired)))
       #+END_SRC

       And I have bound my new utility function so I can use it easily.

       #+BEGIN_SRC emacs-lisp :tangle no
	 (evil-global-set-key 'normal (kbd "<leader> f d f") 'find-name-dired-fallback)
       #+END_SRC

       
***** Lisp manipulation/evaluation

      One of the most interesting features of Emacs is its ability to dynamically evaluate random blocks of Elisp. I frequently swap over to a scratch buffer, type out some functions, execute them to do something useful, and then toggle back to whatever I was doing previously. These bindings make that easier.


      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> l l") 'eval-last-sexp)
	(evil-global-set-key 'normal (kbd "<leader> l L") 'eval-print-last-sexp)
	(evil-global-set-key 'normal (kbd "<leader> l b") 'eval-buffer)
	(evil-global-set-key 'normal (kbd "<leader> l r") 'eval-region)
      #+END_SRC

***** Window manipulation

      Emacs calls what a normal person would call a window a frame. These keybindings manipulate what Emacs calls Windows, which are essentially just individual buffers open in some kind of a split inside a frame. There are bindings for switching the active window a certain direction, etc.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> w h") 'evil-window-left)
	(evil-global-set-key 'normal (kbd "<leader> w j") 'evil-window-down)
	(evil-global-set-key 'normal (kbd "<leader> w k") 'evil-window-up)
	(evil-global-set-key 'normal (kbd "<leader> w l") 'evil-window-right)
	(evil-global-set-key 'normal (kbd "<leader> w H") 'evil-window-move-far-left)
	(evil-global-set-key 'normal (kbd "<leader> w J") 'evil-window-move-far-down)
	(evil-global-set-key 'normal (kbd "<leader> w K") 'evil-window-move-far-up)
	(evil-global-set-key 'normal (kbd "<leader> w L") 'evil-window-move-far-right)

	(evil-global-set-key 'normal (kbd "<leader> w C-H") 'evil-window-move-far-left)
	(evil-global-set-key 'normal (kbd "<leader> w C-J") 'evil-window-move-very-bottom)
	(evil-global-set-key 'normal (kbd "<leader> w C-K") 'evil-window-move-very-top)
	(evil-global-set-key 'normal (kbd "<leader> w C-L") 'evil-window-move-far-right)

	(evil-global-set-key 'normal (kbd "<leader> w s") 'evil-window-split)
	(evil-global-set-key 'normal (kbd "<leader> w v") 'evil-window-vsplit)
	(evil-global-set-key 'normal (kbd "<leader> w d") 'evil-window-delete)
	(evil-global-set-key 'normal (kbd "<leader> w o") 'other-window)
	(evil-global-set-key 'normal (kbd "<leader> w m") 'delete-other-windows)
      #+END_SRC

      There is one exception about frames, here's a keybinding for making a new frame.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> w f") 'make-frame)
      #+END_SRC

***** Buffers

      Surprisingly, I don't do much with buffers. There are more buffer-related commands set by [[*IDO-mode][ido-mode]].

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> b d") 'kill-buffer)
	(evil-global-set-key 'normal (kbd "<leader> b s") 'switch-to-scratch)
	(evil-global-set-key 'normal (kbd "<leader> b b") 'switch-to-buffer)
      #+END_SRC


***** Getting help

      There are a ton of helpful commands for identifying what is going on using ~C-h~.  I have put many of those same bindings under ~leader h~ just because I find it more intuitive and helpful.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> h f") 'describe-function)
	(evil-global-set-key 'normal (kbd "<leader> h v") 'describe-variable)
	(evil-global-set-key 'normal (kbd "<leader> h k") 'describe-key)
	(evil-global-set-key 'normal (kbd "<leader> h n") 'view-emacs-news)
	(evil-global-set-key 'normal (kbd "<leader> h m") 'describe-mode)
	(evil-global-set-key 'normal (kbd "<leader> h i") 'info)
	(evil-global-set-key 'normal (kbd "<leader> h M") 'view-order-manuals)
      #+END_SRC

***** Running console programs

      I really like running shell commands from inside of Emacs. ~shell-command~ will run whatever you ask for in your default shell, then pipe the output into a buffer for you to manipulate.
      
      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> !") 'shell-command)
      #+END_SRC

***** Setting themes

      I often toggle between a few themes depending on if I'm working inside our outside. I use this hotkey to do that.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'normal (kbd "<leader> c t") 'load-theme)
      #+END_SRC


***** Narrowing and widening

      Emacs allows you to "narrow" a given buffer, meaning only display part of it. when a buffer is narrowed, actions you take like searching or replacing only impact the viewable buffer. To "undo" the narrowing, you just need to issue the command "widen"

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-global-set-key 'visual (kbd "<leader> n n") 'narrow-to-region)
	(evil-global-set-key 'normal (kbd "<leader> n n") 'narrow-to-region)
	(evil-global-set-key 'normal (kbd "<leader> n w") 'widen)
	(evil-global-set-key 'visual (kbd "<leader> n w") 'widen)
      #+END_SRC

**** Evil-collection

     We also want to use [[https://github.com/emacs-evil/evil-collection][`evil-collection`]] to set up things for "buffers evil mode doesn't think about by default"

     #+BEGIN_SRC emacs-lisp :tangle config.el
       (use-package evil-collection
	 :after (:all evil magit)
	 :diminish evil-collection-unimpaired-mode
	 :ensure t
	 :config
	 (evil-collection-init))
     #+END_SRC

**** Evil-surround

     Want to surround strings or expressions with things? This is how!

     #+BEGIN_SRC emacs-lisp :tangle config.el
       (use-package evil-surround
	 :after evil
	 :ensure t
	 :config (global-evil-surround-mode))
     #+END_SRC

**** Evil-cleverparens

     [[https://github.com/luxbock/evil-cleverparens][This package]] is really helpful generally for writing Elisp. It has a bunch of features but it shold auto-close parens, and generally make evil mode actions aware of the syntax of lisp.

     #+BEGIN_SRC emacs-lisp :tangle config.el
       (use-package evil-cleverparens
	 :after evil
	 :ensure t
	 :hook ( emacs-lisp-mode . evil-cleverparens-mode ))

     #+END_SRC

**** TODO Undo-tree

     Undo tree is a huge plugin whose features I am probably not using properly. For now I am using it only because undo functionality in Emacs 27 w/ Evil seems to need it. I should spend some time investigating features. Also, once I switch to Emacs 28, I may be able to use a native option.
     
     #+BEGIN_SRC emacs-lisp :tangle config.el
       (use-package undo-tree
	 :ensure t
	 :after evil
	 :diminish
	 :config
	 (evil-set-undo-system 'undo-tree)
	 (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
	 (global-undo-tree-mode 1))
     #+END_SRC

*** vim tab bar


    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package vim-tab-bar
	:ensure t
	:diminish 
	:commands vim-tab-bar-mode
	:hook
	(after-init . vim-tab-bar-mode))
    #+END_SRC

*** Company-mode

    [[http://company-mode.github.io/][Company mode]] is an auto complete plugin (*comp*-lete *any*-thing). I am still exploring how it can be used. Note the hooks set up below. I am only enabling company mode in modes that inherit from ~prog-mode~ because I don't want it popping up constantly while I am typing in org mode or in markdown mode.

    #+BEGIN_SRC emacs-lisp :noweb yes :tangle config.el
      (use-package company
	:ensure t
	:diminish company-mode
	:hook (prog-mode . company-mode)
	:custom
	<<company-variables-config>>
	:config

	<<company-config>>)
    #+END_SRC
**** company variables
     :PROPERTIES:
     :header-args: :noweb-ref company-variables-config
     :END:

     The delay between when company mode starts searching for items and the actual display of items in the UI. This defaults to a half a second, and I'd like it to just appear immediately.

     #+BEGIN_SRC emacs-lisp :tangle no
       (company-idle-delay 0)
     #+END_SRC

     Company by default forces you to type at least 3 characters before it starts making suggestions. I would like it to just appear immediately.

     #+BEGIN_SRC emacs-lisp :tangle no
       (company-minimum-prefix-length 1)
     #+END_SRC

     By default, the company popups do not wrap around when you try to "next" at the end of the list. This is annoying, so lets fix it.

     #+BEGIN_SRC emacs-lisp :tangle no
       (company-selection-wrap-around t)
     #+END_SRC
**** company config
     :PROPERTIES:
     :header-args: :noweb-ref company-config
     :END:

     These are things that I need to execute whenever company mode loads.

***** Backends

     Company and Yasnipppet have some rather odd interactions, since they both make heavy use of the tab key by default. I have tried below to make them play nicely together.

     First, I need to select what backends I would like to use. This is essentially the original list, except I have added in Yasnippet at a high level of priority as well so that it works.


     #+BEGIN_SRC emacs-lisp :tangle no
       (setq company-backends '(company-yasnippet
				company-capf
				company-dabbrev-code
				company-keywords
				company-clang
				company-semantic
				company-etags
				company-files))
     #+END_SRC

***** TODO Random config

      I am not really sure what this does, but I have been using it for a while.
      

      #+BEGIN_SRC emacs-lisp :tangle no
	(company-tng-configure-default)
      #+END_SRC

*** Spacemacs theme

    I like the Spacemacs theme quite a lot, so I'll use it. I have no idea why I have to defer loading to get things working correctly, but for some reason I get an error if I don't.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package spacemacs-theme
	:ensure t
	:defer t
	:init
	(load-theme 'spacemacs-dark t))
    #+END_SRC

*** Which key mode

    Which key is a pannel at the bottom that should display options when a key is pressed.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package which-key
	:ensure t
	:diminish which-key-mode
	:config
	(which-key-mode))
    #+END_SRC
*** Completion 

    There are a bunch of libraries out there for doing suggestion and completion. I have historically used ~ido~ for that purpose, but I recently learned that there is a built in mode that emulates a lot of the functionality of ~ido~ called ~fido-mode~. Since that is built in, I want to give it a try as a replacement.
    

    First up, IDO mode is dependent on ~icomplete~ which is a built in package.
    
    #+BEGIN_SRC emacs-lisp :noweb yes :tangle config.el
      (use-package icomplete
	:custom
	<<completion-variables-config>>
	:config
	<<completion-fido-config>>)
    #+END_SRC

    
**** Completion Customized Variables
     :PROPERTIES:
     :header-args: :noweb-ref completion-variables-config
     :END:

     There are a few things about ~icomplete~ that I like to tweak for my usage. Case insensitivity is the big thing. You can't globally turn off case sensitivity that I know of, but you can disable it on a per-usage basis, which I do here for the file selector:

     #+BEGIN_SRC emacs-lisp :tangle no
       (read-file-name-completion-ignore-case 1)
     #+END_SRC

     And here for the buffer selector:

     #+BEGIN_SRC emacs-lisp :tangle no
       (read-buffer-completion-ignore-case 1)
     #+END_SRC

**** Enable fido-mode
     :PROPERTIES:
     :header-args: :noweb-ref completion-fido-config
     :END:

     Now that we have loaded ~icomplete~ we can enable it:

     #+BEGIN_SRC emacs-lisp :tangle no
       (icomplete-mode 1)
     #+END_SRC

     ~fido-mode~ itself is a customization of ~icomplete~, so we can enable that here:

     #+BEGIN_SRC emacs-lisp :tangle no
       (fido-mode 1)
     #+END_SRC

     And I don't like that ~icomplete~ and ~fido-mode~ show their completion horizontally across the screen. I much prefer it to be done vertically, so I can enable that:

     #+BEGIN_SRC emacs-lisp :tangle no
       (fido-vertical-mode)
     #+END_SRC

*** Magit

    I love [[https://magit.vc/][Magit]]. Enough said.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package magit
	:ensure t
	:after evil
	:config
	(evil-global-set-key 'normal (kbd "<leader> g s") 'magit-status))
    #+END_SRC
*** Org mode
**** Various org mode configuration
     :PROPERTIES:
     :header-args: :noweb-ref org-variables-config
     :END:
     
***** Variable tweaks for Org mode

      There are a ton of options for org mode and I only use a very small number of them. Here I attempt to organize my config into subsections that can be tangled elsewhere using ~noweb~.

      Notice the properties on this header. It means that all the source blocks below this header will have that name, so we can reference them all at once. 

******* Set up org agenda files

	Note, you will probably want to override these variables in your local config.
      
	#+BEGIN_SRC emacs-lisp :tangle no
	  (defvar org-directory nil) ; Set this in your local.org file!
	  (defvar org-jira-link "") ; Set this in your local.org file!
	#+END_SRC

	First up, I need to define what my org mode agenda files are. I'm going to wind up using these all over the place, so I am going to define them all together

	#+BEGIN_SRC emacs-lisp :tangle no
	  (setq todo-org "todo.org")
	  (setq professional-org "professional.org")
	  (setq personal-org "personal.org")
	  (setq school-org "school.org")
	  (setq notes-org "notes.org")
	  (setq inbox-org "inbox.org")
	  (setq project-org "project.org")
	  (setq reviews-org "reviews.org")
	  (setq meetings-org "meetings.org")
	  (setq interruption-org "interruption.org")
	  (setq contact-log-org "contact-log.org")
	  (setq one_on_one_topics-org "one-on-one-topics.org")
	#+END_SRC
      
	Once I have those variables, I am going to want to concatenate the path to my org files to them. To enable that, we should write a handly little method
      
	#+BEGIN_SRC emacs-lisp :tangle no
	  (defun org-concat-org-directory (fileName)
	    (concat org-directory fileName))
	#+END_SRC
      
	#+BEGIN_SRC emacs-lisp :tangle no
	  (defun setup-org-agenda-files ()
	    (add-to-list 'org-agenda-files (org-concat-org-directory todo-org))
	    (add-to-list 'org-agenda-files (org-concat-org-directory professional-org))
	    (add-to-list 'org-agenda-files (org-concat-org-directory personal-org))
	    (add-to-list 'org-agenda-files (org-concat-org-directory school-org))
	    (add-to-list 'org-agenda-files (org-concat-org-directory notes-org))
	    (add-to-list 'org-agenda-files (org-concat-org-directory inbox-org))
	    (add-to-list 'org-agenda-files (org-concat-org-directory project-org))
	    (add-to-list 'org-agenda-files (org-concat-org-directory meetings-org))
	    (add-to-list 'org-agenda-files (org-concat-org-directory interruption-org))
	    (add-to-list 'org-agenda-files (org-concat-org-directory contact-log-org)))
	#+END_SRC

	The I have a number of files defined elsewhere. This function should take all those file names and append them into whatever org-directory the system has set up.

	#+BEGIN_SRC emacs-lisp :tangle no
	  (setup-org-agenda-files)
	#+END_SRC

******* Configure capture templates

	In this section, I define a bunch of lists that represent capture templates. Normally, one would have one large list that gets assigned to ~org-capture-templates~, but I have many templates for many situations, so I'd like to break them apart and document each one individually.  To do that requires some subtletly, though, because a capture template needs to be in a form like this:

	#+BEGIN_SRC emacs-lisp :tangle no 
	  `("t" ; A "key" to use as a hotkey in the template selection UI
	    "Todo" ; A description for the template
	    entry ; A type, usually entry
	    (file ,(concat org-directory inbox-org)) ; A function that takes
						  ; some input, which must
						  ; resolve to a string, so
						  ; it must be interpreted!
	    "* TODO %?\n  %i\n  %a") ; An actual template string
	#+END_SRC

	This is important, because putting a function call in the ~(file (concat ...))~ line will cause things to not evaluate correctly, so we have to make use of [[*Backtick and comma notation][backtick and comma notation]].

******** Todo template

	 This template is just a simple TODO template that drops things in my inbox file.

	 #+BEGIN_SRC emacs-lisp :tangle no
	   (setq org-todo-capture-template
		 `("t"
		   "Todo"
		   entry
		   (file ,(concat org-directory inbox-org))
		   "* TODO %?\n  %i\n  %a"))
	 #+END_SRC
       
******** Interruption template

	 This template is to note times that I am interrupted by something unexpected. I mostly use these entries to track time and see where I am getting interrupted at work.

	 #+BEGIN_SRC emacs-lisp :tangle no
	   (setq org-interruption-capture-template
		 `("i"
		   "interruption"
		   entry
		   (file+datetree ,(concat org-directory interruption-org))
		   "* Interrupted by %?\n%t"))
	 #+END_SRC
       
******** Note template

	 All of my notes start off as "notes to self" in my notes file. I regularly prune that section to store things that I want to reference in more permanent locations. This is basically a separate inbox just for my notes. I may in the future just redirect this to drop things right in my normal inbox file.

	 #+BEGIN_SRC emacs-lisp :tangle no
	   (setq org-note-capture-template
		 `("n"
		   "Note to self"
		   entry
		   (file+headline ,(concat org-directory notes-org) "Note to Self")
		   "* Note: %?\nEntered on %U\n  %i\n  %a"))
	 #+END_SRC

******** Contact template

	 The contact template helps me track important interactions that I have.  I use this file sort of like a personal CRM so that I can easily check in on whether or not I know someone or what my last meaningful interaction with them was. I only use this for professional contact.

	 #+BEGIN_SRC emacs-lisp :tangle no
	   (setq org-contact-capture-template
		 `("c"
		   "contact"
		   entry
		   (file+datetree ,(concat org-directory contact-log-org))
		   "* Contacted by: %\\1%?
						     :PROPERTIES:
						     :NAME:       %^{Name}
						     :COMPANY:    %^{Company}
						     :HEADHUNTER: %^{Headhunter|Y|N}
						     :SOURCE:     %^{Source|LinedIn|Phone|Email}
						     :END:"))
	 #+END_SRC

******** One on one template
     
	 I have regular one on one meetings with people, both as a mentor and to get mentoring. As such, I often need to keep track of a list of topics to discuss with different people on a given week. This template generates a note in a "weekly datetree" for each of those conversations.

	 #+BEGIN_SRC emacs-lisp :tangle no
	   (setq org-one-on-one-capture-template
		 `("wo"
		   "one on one topics"
		   plain ; also unsure what plain actually means
		   (file+function ,(concat org-directory one_on_one_topics-org) org-week-datetree)
		   "*** %?")) ; note the 3 asterisks.  Would be nice to figure out how to do that without but eh.
	 #+END_SRC

******** Query template

	 I write a lot of SQL queries.  Sometimes this is a migration to set up data for a new enhancement, and sometimes it's a one-off query to help investigate something. This template asks for a DB to run against, a ticket (like Jira), and a type (which is a flexible field that could mean anything) and saves it in my inbox so I can archive it for reference later.

	 #+BEGIN_SRC emacs-lisp :tangle no
	   (setq org-query-capture-template
		 `("wQ"
		   "Datebase Query"
		   entry
		   (file ,(concat org-directory inbox-org))
		   "* %\\2%?
					   :PROPERTIES:
					   :DATABASE: %^{database|STATIC_TABLES|TENANTS}
					   :TICKET:   %^{ticket}
					   :TYPE:     %^{type|DATA|POST_MIGRATION}
					   :END:
					   ,#+BEGIN_SRC sql :tangle %\\2-%\\1-%\\3.txt
					   ,#+END_SRC
					   "))
	 #+END_SRC

******** Jira ticket

	 I work on projects that use Jira a lot, so often I find myself wanting to keep track of a ticket. Jira boards are nice, but my agenda with all my other tasks is nicer. This template will format a nice entry in my todo list with a link to your Jira instance.  Just make sure ~org-jira-link~ is set prior to running this template.

	 #+BEGIN_SRC emacs-lisp :tangle no
	   (setq org-jira-ticket-capture-template
		 `("wj"
		   "Jira ticket"
		   entry
		   (file ,(concat org-directory inbox-org))
		   ,(concat "* TODO %\\1%?
					   [[" org-jira-link "%^{ticket}][%\\1]]")))
	 #+END_SRC

******** Meeting capture template

	 I am in a lot of meetings. I also often fail to remember things. this capture template will create a new entry in the meetings file under the given day (in a date tree) to make it easier for me to find meetings if I know about when they happened.

	 #+BEGIN_SRC emacs-lisp :tangle no
	   (setq org-meeting-minute-capture-template
		 `("wm"
		   "Meeting notes"
		   entry
		   (file+datetree ,(concat org-directory meetings-org))
		   "* %?\n%U\n"))
	 #+END_SRC

******** Emacs tweak capture template

	 I make a lot (and I mean a lot...) of tweaks to my Emacs configuration. I so often run across a package to implement or a thing to investigate, that I have started keeping a separate todo list that I try to keep prioritized in my school org file.


	 #+BEGIN_SRC emacs-lisp :tangle no
	   (setq org-emacs-tweak-capture-template
		 `("e"
		   "Emacs tweak"
		   entry
		   (file+olp,(concat org-directory school-org) "Research Topics" "Software engineering & Computer Science" "Emacs reading & config changes")
		   "* %?:emacs:\nEntered on %U\n  %i\n  %a "))
	 #+END_SRC


******* Set capture templates

	Org has a system called "[[https://orgmode.org/manual/Using-capture.html][capture]]" data from wherever you are. You can fire that off using ~org-capture~. I have set up capture templates elsewhere and this line should combine all my capture templates into the final list that Emacs actually reads from.

	You can also group templates behind prefixes. I do this with "work" specific templates. Templates that are specific to "work" are hidden behind ~w~ which has its own description as seen below.

	#+BEGIN_SRC emacs-lisp :tangle no
	  (setq org-capture-templates
		`(,org-todo-capture-template 
		  ,org-note-capture-template
		  ,org-interruption-capture-template
		  ,org-contact-capture-template 
		  ,org-emacs-tweak-capture-template
		  ("w" "Templates around office/work stuff")
		  ,org-one-on-one-capture-template
		  ,org-query-capture-template 
		  ,org-jira-ticket-capture-template
		  ,org-meeting-minute-capture-template))
	#+END_SRC

******* Agenda config

	I happen to like seeing two weeks at once in my agenda. This line should make that the default view.

	#+BEGIN_SRC emacs-lisp :tangle no
						  ; (setq org-agenda-span 14)
	#+END_SRC

	This changes the [[https://orgmode.org/manual/Refile-and-Copy.html][refile]] targets. Refile is a tool for re-organizing org mode files. In my case, I want to be able to refile to files and not just org headers. This should make that possible!

	#+BEGIN_SRC emacs-lisp :tangle no
	  (setq org-refile-targets
		(quote
		 ((nil :maxlevel . 5)
		  (org-agenda-files :maxlevel . 5))))
	#+END_SRC

	+This change should make it so that the UI that displays "where" you are in a org heading tree shows as a file path. So if you have a doc that contains a header called Heading 1 and a subheading called Subheading 1, if you are refiling into Subheading 1 you will see Heading 1/Subheading 1 in the refile auto-complete.+
	

	This doesn't behave properly with fido-mode, and I haven't been able to figure out why, so I have it set to ~nil~ for now. 

	#+BEGIN_SRC emacs-lisp :tangle no
	  (setq org-refile-use-outline-path nil)
	#+END_SRC

******* Task keywords

	You can set what states are valid for tasks in org files globally. I do sometimes override this on a per-file basis as it's appropriate, so I don't have many states set up here.

	#+BEGIN_SRC emacs-lisp :tangle no
	  (setq org-todo-keywords
		'((sequence "TODO(t)" "IN_PROGRESS(p)" "WAITING(w)" "TO_REVIEW(r)" "|" "DONE(d)" "CANCELED(c)" "REVIEWED(R)")))
	#+END_SRC
******* org-log

	I have had some issues with different apps logging repeating tasks and I don't usually care about tracking it, so this should just disable that for now.


	#+BEGIN_SRC emacs-lisp :tangle no
	  (setq org-log-repeat nil)
	#+END_SRC

***** Org datetree functions

      I have two custom date-tree functions that I wrote to make
      capture templates easier to work with. These were based on [[https://emacs.stackexchange.com/questions/48414/monthly-date-tree][this]].
      
      First up, this tree is a "datetree" only to the month.
      #+BEGIN_SRC emacs-lisp :tangle no
	(defun org-month-datetree()
	  (org-datetree-find-date-create (calendar-current-date))
	  ;; Kill the line because this date tree will involve a subheading for the week
	  (kill-line))
      #+END_SRC
      
      Next up, a date tree th a week
      #+BEGIN_SRC emacs-lisp :tangle no
	(defun org-week-datetree()
	  (org-datetree-find-iso-week-create (calendar-current-date))
	  ;; Kill the line because this date tree will involve a subheading for the day
	  (kill-line))
      #+END_SRC

***** inserting blocks

      I borrowed this [[https://www.handsonprogramming.io/blog/2021/12/source-block/][from a blog post]] and adapted it for my needs.

      #+BEGIN_SRC emacs-lisp :tangle no
	(defun org-insert-src-block (src-code-type)
	  "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
	  (interactive
	   (let ((src-code-types
		  '(
		    "emacs-lisp"
		    "python"
		    "C"
		    "sh"
		    "js" 
		    "sql" 
		    "latex"
		    "lisp"
		    "org" 
		    "scheme" )))
	     (list (ido-completing-read "Source code type: " src-code-types))))
	  (progn
	    (newline-and-indent)
	    (insert (format "#+BEGIN_SRC %s\n" src-code-type))
	    (newline-and-indent)
	    (insert "#+END_SRC\n")
	    (previous-line 2)
	    (org-edit-src-code)))
      #+END_SRC

***** Keybindings
      :PROPERTIES:
      :header-args: :noweb-ref org-keybindings
      :END:

      I use a lot of custom keybindings for org-mode. Most of them are entirely self explanatory, so I am not going to include much documentation of them.

      #+BEGIN_SRC emacs-lisp :tangle no
	(evil-define-key 'normal org-mode-map (kbd "<localleader> d s") 'org-schedule)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> d d") 'org-deadline)

	(evil-define-key 'normal org-mode-map (kbd "<localleader> s r") 'org-refile)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> s n") 'org-narrow-to-subtree)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> s a") 'org-archive-subtree-default)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> s w") 'widen)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> s h") 'org-promote)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> s l") 'org-demote)

	(evil-define-key 'normal org-mode-map (kbd "<localleader> p") 'org-priority)

	(evil-define-key 'normal org-mode-map (kbd "<localleader> C i") 'org-clock-in)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> C o") 'org-clock-out)

	(evil-define-key 'normal org-mode-map (kbd "<localleader> T T") 'org-todo)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> b t") 'org-babel-tangle)

	(evil-define-key 'normal org-mode-map (kbd "<localleader> i l") 'org-insert-link)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> i i") 'org-insert-item)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> i t") 'org-set-tags-command)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> i T t") 'org-table-create)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> i T r") 'org-table-insert-row)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> i T c") 'org-table-insert-column)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> i s") 'org-insert-src-block)

	(evil-define-key 'normal org-mode-map (kbd "<localleader> <return>") 'org-open-at-point)

	(evil-define-key 'edit 'org-mode-map (kbd "<M-return>") 'org-insert-item)

	(evil-global-set-key 'normal (kbd "<leader> a o a") 'org-agenda)
	(evil-global-set-key 'normal (kbd "<leader> a o C j") 'org-agenda-clock-goto)
	(evil-global-set-key 'normal (kbd "<leader> a o c") 'org-capture)
      #+END_SRC

**** Require package

     The actual org-mode package 
     #+BEGIN_SRC emacs-lisp :noweb yes :tangle config.el
       (use-package org
	 :ensure t
	 :custom
	 (org-agenda-span 14)
	 (org-adapt-indentation t)
	 :config
	 (add-hook 'org-mode-hook (lambda () (setq mode-name "O")))
	 (add-hook 'org-agenda-mode-hook (lambda () (setq mode-name "OA")))
	 <<org-variables-config>>
	 <<org-keybindings>>)
     #+END_SRC
     
**** evil-org

     #+BEGIN_SRC emacs-lisp :tangle config.el
       (use-package evil-org
	 :ensure t
	 :after org
	 :hook (org-mode . (lambda () evil-org-mode))
	 :config
	 (require 'evil-org-agenda)
	 (evil-org-agenda-set-keys)
	 (define-key global-map "\C-ca" 'org-agenda))
     #+END_SRC

**** Org bullets

     A really cool plugin that makes pretty bullets

     #+BEGIN_SRC emacs-lisp :tangle config.el
       (use-package org-bullets
	 :after org
	 :ensure t
	 :config
	 (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
     #+END_SRC

**** org-ql 

     [[https://github.com/alphapapa/org-ql][Org-ql]], similar to the older [[https://github.com/alphapapa/org-rifle][org-rifle]],is a plugin for searching your org headers/body. I primarily just use it to find tasks/notes in either my org-directory or in my agenda (a smaller list).

     #+BEGIN_SRC emacs-lisp :tangle config.el
       (use-package org-ql
	 :ensure t
	 :config
	 (evil-global-set-key 'normal (kbd "<leader> a o s d") 'org-ql-find-in-org-directory)
	 (evil-global-set-key 'normal (kbd "<leader> a o s a") 'org-ql-find-in-agenda)
	 (evil-global-set-key 'normal (kbd "<leader> a o s f") 'org-ql-find))
     #+END_SRC

**** org-pomodoro

     [[https://github.com/marcinkoziej/org-pomodoro][Org pomodoro]] is a tool for doing the [[https://en.wikipedia.org/wiki/Pomodoro_Technique][pomodoro technique]] in Emacs org mode.


     #+BEGIN_SRC emacs-lisp :tangle config.el
       (use-package org-pomodoro
	 :ensure t
	 :after org
	 :config
	 (evil-define-key 'normal org-mode-map (kbd "<localleader> C p") 'org-pomodoro)
	 (evil-define-key 'motion org-agenda-mode-map (kbd "c p") 'org-pomodoro))

     #+END_SRC
     
*** Editorconfig
    
    Editorconfig is a standard for keeping code editing settings in sync across tools and teams.  Someone can check in a .Editorconfig file at the root of a repo, and their editors should respect the settings. This should do that for me!

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package editorconfig
	:ensure t
	:diminish editorconfig-mode
	:config
	(editorconfig-mode 1))
    #+END_SRC
*** Smartparens

    Smartparens is a minor mode that can automatically close parentheses and other things that must be matched. I use this specifically in Lisp-mode because it makes writing Lisp a lot nicer.

    I am pinning this package specifically to MELPA for now because the version in ELPA is very out of date and throws warnings about deprecated packages.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package smartparens
	:ensure t
	:pin melpa
	:hook ((emacs-lisp-mode . smartparens-mode)
	       (vue-mode . smartparens-mode)
	       (typescript-mode . smartparens-mode)))
    #+END_SRC
*** Web mode

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package web-mode
	:ensure t
	:config
	(add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
	(add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
	(evil-define-key 'normal web-mode-map (kbd "<localleader> <tab>") 'web-mode-fold-or-unfold)
	(evil-define-key 'normal web-mode-map (kbd "<localleader> i l") 'web-mode-file-link)
	(evil-define-key 'normal web-mode-map (kbd "<localleader> g t") 'web-mode-navigate)
	(evil-define-key 'normal web-mode-map (kbd "<localleader> g j") 'web-mode-tag-next)
	(evil-define-key 'normal web-mode-map (kbd "<localleader> g k") 'web-mode-tag-previous))
	#+END_SRC
*** Zettelkasten

    This is a plugin that isn't in MELPA for now, and I can't seem to convince it to load by adding it to ~load-path~ so I am instead going to manually require it.
    #+BEGIN_SRC emacs-lisp :tangle config.el
      (require 'zettelkasten-mode "~/.emacs.d/plugins/zettelkasten/zettelkasten.el")
    #+END_SRC

    To actually configure it, though, I still want to use ~use-package~, so now that it's loaded, I can use ~use-package~ to activate it and set up the basic keybindings. Yay, some consistency!
    
    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package zettelkasten-mode
	:diminish zettelkasten-mode
	:config
	(evil-global-set-key 'normal (kbd "<leader> a z c") 'zettel-create-new)
	(evil-global-set-key 'normal (kbd "<leader> a z i") 'zettel-insert-and-create-new)
	(zettelkasten-mode 1))
    #+END_SRC
*** Markdown-mode

    I use Markdown for quite a lot, so I need a markdown mode. This one could probably be configured more.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package markdown-mode
	:ensure t
	:custom
	(markdown-hide-markup 1)
	(markdown-hide-urls 1)
	:config
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> <return>") 'markdown-do)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> g f") 'markdown-outline-next-same-level)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> g b") 'markdown-outline-previous-same-level)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> g n") 'markdown-outline-next)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> g p") 'markdown-outline-previous)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> g u") 'markdown-outline-up)

	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i f") 'markdown-insert-footnote)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i w") 'markdown-insert-wiki-link)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i i") 'markdown-insert-image)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i l") 'markdown-insert-link)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i H") 'markdown-insert-hr)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i h 1") 'markdown-insert-header-atx-1)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i h 2") 'markdown-insert-header-atx-2)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i h 3") 'markdown-insert-header-atx-3)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i t t") 'markdown-insert-table)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i t r") 'markdown-table-insert-row)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i t c") 'markdown-table-insert-column)

	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> s h") 'markdown-promote)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> s l") 'markdown-demote)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> S h") 'markdown-toggle-markup-hiding)

	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> p") 'markdown-live-preview-mode)

	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> e e") 'markdown-export)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> e p") 'markdown-export-and-preview))
    #+END_SRC
*** Python mode

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package python-mode
	:ensure t)
    #+END_SRC
*** Vue mode

    I need a major mode for Vue files!

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package vue-mode
	:ensure t
	:hook ((vue-mode . (lambda () (visual-fill-column-mode -1)))
	       (vue-mode . flyspell-prog-mode))
	:mode "\\.vue\\'")
    #+END_SRC
*** Tab bar mode

    This should enable a tab bar. This is built into emacs as of 27, I think. Each tab is a configuration of windows, so the splits and whatnot should be maintained?

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package tab-bar
	:config
	(evil-global-set-key 'normal (kbd "<leader> C-t") 'tab-new)
	(evil-global-set-key 'normal (kbd "<leader> <C-tab>") 'tab-next)
	(evil-global-set-key 'normal (kbd "<leader> <C-S-tab>") 'tab-previous)
	(evil-global-set-key 'normal (kbd "<leader> <C-backtab>") 'tab-previous)
	(evil-global-set-key 'normal (kbd "<leader> C-w") 'tab-close))
    #+END_SRC
*** Powershell mode

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package powershell
	:ensure t)
    #+END_SRC 
*** Dockerfiles

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package dockerfile-mode
	:ensure t)
    #+END_SRC
*** Typescript mode

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package typescript-mode
	:ensure t)
    #+END_SRC
*** TODO Flycheck mode

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package flycheck
	:ensure t)
    #+END_SRC

*** Csharp mode

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package csharp-mode
	:ensure t)
    #+END_SRC

*** Treemacs

    
**** Treemacs itself

     #+BEGIN_SRC emacs-lisp :tangle config.el
       (use-package treemacs
	 :ensure t
	 :init
	 (evil-global-set-key 'normal (kbd "<leader> p t") 'treemacs)
	 :config
	 ;; The default width and height of the icons is 22 pixels. If you are
	 ;; using a Hi-DPI display, uncomment this to double the icon size.
	 ;; (treemacs-resize-icons 44)

	 (treemacs-follow-mode t)
	 (treemacs-filewatch-mode t)
	 (treemacs-fringe-indicator-mode 'always)

	 (pcase (cons (not (null (executable-find "git")))
		      (not (null treemacs-python-executable)))
	   (`(t . t)
	    (treemacs-git-mode 'deferred))
	   (`(t . _)
	    (treemacs-git-mode 'simple)))

	 (treemacs-hide-gitignored-files-mode nil)
	 (treemacs-project-follow-mode)
	 (evil-global-set-key 'normal (kbd "<leader> f t") 'treemacs))

       (use-package treemacs-evil
	 :after (treemacs evil)
	 :ensure t)

       (use-package treemacs-icons-dired
	 :hook (dired-mode . treemacs-icons-dired-enable-once)
	 :ensure t)

       (use-package treemacs-magit
	 :after (treemacs magit)
	 :ensure t)

       (use-package treemacs-tab-bar ;;treemacs-tab-bar if you use tab-bar-mode
	 :after (treemacs)
	 :ensure t
	 :config (treemacs-set-scope-type 'Tabs))
     #+END_SRC

*** project.el

    I need a convenient way to remember "the current project"
    #+BEGIN_SRC emacs-lisp :tangle config.el
      (defun project-remember-current ()
	(interactive)
	(project-remember-project (project-current)))
    #+END_SRC

     #+BEGIN_SRC emacs-lisp :tangle config.el
       (use-package project
	 :config
	 (evil-global-set-key 'normal (kbd "<leader> p r") 'project-remember-current)
	 (evil-global-set-key 'normal (kbd "<leader> p s") 'project-switch-project)
	 (evil-global-set-key 'normal (kbd "<leader> p b") 'project-switch-to-buffer)
	 (evil-global-set-key 'normal (kbd "<leader> p f") 'project-find-file)
	 (evil-global-set-key 'normal (kbd "<leader> p d") 'project-dired)
	 (evil-global-set-key 'normal (kbd "<leader> p !") 'project-shell-command)
	 (evil-global-set-key 'normal (kbd "<leader> p c") 'project-compile))
     #+END_SRC
*** Flyspell mode

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package flyspell
	:ensure t
	:hook
	((prog-mode . flyspell-prog-mode)
	 (vue-mode . flyspell-prog-mode)
	 (text-mode . flyspell-mode))
	:config
	(evil-global-set-key 'normal (kbd "<leader> s c") 'flyspell-correct-word-before-point)
	(evil-global-set-key 'normal (kbd "<leader> s b") 'flyspell-buffer))
    #+END_SRC

*** Visual fill column 

    This minor mode allows me to softly (without inserting a new line) wrap lines. I mostly use this when writing markdown notes so that they look decent on my mobile devices.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package visual-fill-column
	:ensure t
	:hook (markdown-mode . visual-fill-column-mode))
    #+END_SRC

    This uses visual line mode, which is built into emacs itself. That said I would like it to turn on in org-mode and in markdown-mode.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package visual-line-mode
	:hook ((text-mode . visual-line-mode))
	(visual-line-mode . (lambda () (diminish 'visual-line-mode))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package adaptive-wrap
	:ensure t
	:hook (text-mode . adaptive-wrap-prefix-mode))
    #+END_SRC

*** Yaml mode

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package yaml-mode
	:ensure t)
    #+END_SRC

*** Auto updates

    I like to have my packages periodically update since I tend to forget to do that on a regular basis.


    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package auto-package-update
	:ensure t
	:custom
	(auto-package-update-delete-old-versions t)
	(auto-package-update-prompt-before-update t)
	(auto-package-update-hide-results t)
	:config
	(auto-package-update-maybe))
    #+END_SRC

*** TODO dired

    I know that dired mode and dired-x are a thing, but I don't really make much use of them in my current workflow. I should change that and revisit this in the future.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package dired)
    #+END_SRC


    I can probably omit the files using dired-x instead of doing that via the listing switches, but this is okay for now.
    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package dired-x
	:after dired
	:demand t 
	:config
	(setq dired-omit-files
	      (concat dired-omit-files
		      "\\|^.\\|")))
    #+END_SRC

    References for dired
    + [[https://www.gnu.org/software/emacs/manual/html_mono/dired-x.html#Installation][emacs manual on dired-x]]
    + [[https://www.masteringemacs.org/article/dired-shell-commands-find-xargs-replacement][mastering emacs article mentioning dired-x]]
    + [[https://www.emacswiki.org/emacs/DiredExtra#Dired_X][emacs wiki on dired-x]]
    + [[https://github.com/mattss/emacs.d/blob/4e3cb1f597a271a8fba99729f66606f8ae5db8b8/init.el#L120][an example where somebody figured out how to make things work nicely with use-package]] 

*** Yasnippet

    [[https://github.com/joaotavora/yasnippet][Yasnippet]] is a library for expanding snippets to autocomplete code. It has a ton of options, so I have just set it up in a basic way to test it out.


    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package yasnippet
	:ensure t
	:diminish (yas-minor-mode . " Y") 
	:hook
	(prog-mode . yas-minor-mode)
	(vue-mode . yas-minor-mode)
	:config
	(evil-global-set-key 'insert (kbd "<C-tab>") 'yas-expand))
    #+END_SRC

    Of course Yasnipets hasn't come with its own default snippets for a long time, so [[https://github.com/AndreaCrotti/yasnippet-snippets][here is a community maintained package]] that has a ton of useful ones!

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package yasnippet-snippets
	:ensure t)
    #+END_SRC

*** prettier-js mode

    Prettier-js is a [[https://prettier.io/][project for formatting javascript and typescript code]]. It is really common in front end projects these days. I would like it to run whenever I save, which is exactly what this plugin does. I just have to make sure it gets active on the right modes.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package prettier-js
	:ensure t
	:hook ((typescript-mode . prettier-js-mode)
	       (javascript-mode . prettier-js-mode)
	       (vue-mode . prettier-js-mode)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package add-local-node-modules
	:load-path "plugins/add-local-node-modules"
	:config
	(add-hook 'javascript-mode-hook #'add-local-node-modules)
	(add-hook 'typescript-mode-hook #'add-local-node-modules)
	(add-hook 'vue-mode-hook #'add-local-node-modules))
    #+END_SRC

*** Diminish

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package diminish
	:ensure t)
    #+END_SRC

*** dashboard

    [[https://github.com/emacs-dashboard/emacs-dashboard][Dashboard]] is a package to set up a cool opening screen. It really isn't all that practical, but it looks neat and I like it.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package dashboard
	:ensure t
	:config
	(dashboard-setup-startup-hook)
	(setq dashboard-projects-backend 'project-el)
	(setq dashboard-items '((recents  . 5)
			      (bookmarks . 5)
			      (projects . 5)
			      (agenda . 5)))
	(evil-global-set-key 'normal (kbd "<leader> b D") 'dashboard-open))
    #+END_SRC

*** Bookmarks

    Bookmarks are a built in feature of Emacs that allow you to remember certain locations in files for reference later. Other packages (like dashboard.el) display the output of this feature, though you can also just list them with the built-in UI. This isn't a package as much as it's just a built in feature of Emacs. As such, there's no package to use, but I want to set keybindings anyway.


    #+BEGIN_SRC emacs-lisp :tangle config.el
      (evil-global-set-key 'normal (kbd "<leader> B m") 'bookmark-set)
      (evil-global-set-key 'normal (kbd "<leader> B l") 'bookmark-bmenu-list)
    #+END_SRC
    
*** Eglot mode

    I have historically used LSP mode to get complex IDE-style stuff in Emacs, but I have been trying to make do with [[https://www.gnu.org/software/emacs/manual/html_node/eglot/index.html][Eglot]] instead. It's a much simpler interface and it overloads built-in functionality in Emacs instead of lsp-mode's approach of providing its own interface.

    #+BEGIN_SRC emacs-lisp :tangle config.el :noweb yes
      (use-package eglot
	:hook ((csharp-mode . eglot-ensure)))
    #+END_SRC

*** LSP-mode

    For some languages, eglot mode doesn't work well (namely, Vue). LSP mode works better.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (use-package lsp-mode
	:ensure t
	:config
	(evil-define-key 'normal lsp-mode-map (kbd "<localleader>") lsp-command-map)
	:hook ((vue-mode . lsp-mode)
	       (typescript-mode . lsp-mode)))

      (use-package lsp-treemacs
	:ensure t)
    #+END_SRC
** Backups

   Emacs keeps backups of files that you have open in case something bad happens and they need to be recovered. They're stored in the same directory as the file you are working on by default, and end in a "~". I find all these extra files pretty bothersome, but I similar to what I do with undo-tree, I want to store them in a central location. Stolen from [[https://stackoverflow.com/questions/2680389/how-to-remove-all-files-ending-with-made-by-emacs][Stack Overflow]].

   #+BEGIN_SRC emacs-lisp :tangle config.el
     (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backup")))
	   backup-by-copying t
	   version-control t
	   delete-old-versions t
	   kept-new-versions 20
	   kept-old-versions 5)
   #+END_SRC

   There is also an "auto save" functionality that saves files every few minutes in case of a crash. These files are usually dropped inline just like the backup files, but they are usually named #filename#. This is super useful, but also junks up git repos, etc, so lets store them in our .emacs.d as well.
   
   #+BEGIN_SRC emacs-lisp :tangle config.el
     (setq auto-save-file-name-transforms
	   `((".*" ,(concat user-emacs-directory "saves/") t)))
   #+END_SRC
** Tweaks

   This is a collection of minor random tweaks that I like that don't make sense anywhere else in my config. It's a junk drawer.

*** UI

    Some random UI tweaks.

**** Y/N

     I find Emacs' default tendency to ask you to type "yes" or "no" in prompts annoying. I prefer it to just be "y" or "n". Borrowed from [[https://www.masteringemacs.org/article/disabling-prompts-emacs][mastering Emacs]].  
     #+BEGIN_SRC emacs-lisp :tangle config.el
       (setq use-short-answers t)
     #+END_SRC


*** Server start

    I am experimenting with using [[https://www.emacswiki.org/emacs/EmacsClient][emacs-client]]. this is a way to launch Emacs in the background and connect to it whenever you need an editor, instead of spinning up a new instance every time. To do this, I first have to start a server, then I need to launch an Emacs client using the separate shortcut.

    #+BEGIN_SRC emacs-lisp :tangle config.el
      (server-start)
    #+END_SRC


** Visual changes

   I like being able to see when I am looking at the first or last line in a buffer. This should show that in the margin around the buffer.

   #+BEGIN_SRC emacs-lisp :tangle config.el
     (setq-default indicate-buffer-boundaries 'left)
   #+END_SRC

   I also don't like the cursor blinking like a terminal from the 60s

   #+BEGIN_SRC emacs-lisp :tangle config.el
     (blink-cursor-mode -1)
   #+END_SRC

   I also like having the line the cursor is currently on hilighted a different color to make it easier to see. I have this turned on only for things that inherit ~prog-mode~ because it helps keep the line highlighting when writing prose.

   #+BEGIN_SRC emacs-lisp :tangle config.el
     (let
	 ((hl-line-hooks '(text-mode-hook prog-mode-hook)))
       (mapc
	(lambda (hook)
	  (add-hook hook 'hl-line-mode))
	hl-line-hooks))
   #+END_SRC

*** Fonts

    Fonts are a complicated topic and I expect this section to change quite a lot.  I happen to really like the Spacemacs font (SourceCodePro) which is an adobe font.

    Originally, I was using ~set-frame-font~ to set the font, but that caused problems when I switched to using EmacsClient to attach to a background Emacs instance (the new window would appear with a miniscule font size that was unintelligible on my laptop). I have switched to ~default-frame-alist~, [[https://emacs.stackexchange.com/questions/35820/opening-emacsclient-n-c-opens-a-small-frame-with-small-fonts][based on this post]], and that seems to have fixed the issue.
    
    #+BEGIN_SRC  emacs-lisp :tangle config.el
      (setq default-frame-alist '((font . "Source Code Pro")))
    #+END_SRC
    
* Sources

  + [[https://masteringemacs.org/article/beginners-guide-to-emacs][Mastering Emacs Beginners Guide]]
  + [[https://git.sr.ht/~ashton314/emacs-bedrock][Emacs Bedrock]]
  + [[https://sachachua.com/blog/][Sachachua's blog]]
  + [[https://github.com/chrisdone/elisp-guide][Elisp guide]]
  + [[https://ianyepan.github.io/posts/setting-up-use-package/][Blog post about use-package]]
  + [[https://github.com/ianyepan/yay-evil-emacs][YayEvilEmacs]] (reference for different config parts)

* Notes
** Backtick and comma notation

   Normally when initializing a list, one would use the form:

   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar my-list '(a b c))
   #+END_SRC

   Which is really just a shortcut for:

   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar my-list (list a b c))
   #+END_SRC

   This is all well and good, until you need to do something that would require you to not pass a variable, such as in a macro.  For example:
   

   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar foo 'asdf)
     (defvar my-list '(a b c foo))
   #+END_SRC

   isn't going to have the effect you want (having the atom ~asdf~ in your list). In this case, you can use the backtick (`) in place of the quote. It's functionally equivalent to the quote form, except it will cause expressions preceded with a comma to be evaluated for their result. So instead of the above, you could do:

   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar foo 'asdf)
     (defvar my-list `(a b c ,foo))
   #+END_SRC

   Which will give you the expected result.
   
** Scratch ERT space

   I just discovered ERT so I added a simple example.
   #+BEGIN_SRC emacs-lisp :tangle tests.el
     (ert-deftest testing-ert ()
       "This is a test"
       (should (equal 1 1)))
   #+END_SRC
